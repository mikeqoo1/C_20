// Package nodejs turns our small AST into a runnable Node.js script.
//
// Emission strategy (MVP):
//  - One .js file per COBOL program-id.
//  - Insert a tiny runtime shim next to output (cobol_compat.js).
//  - Use console.log for DISPLAY literals.
//
// We add generous comments into the generated JS to help future devs.
package nodejs

import (
    "fmt"
    "os"
    "path/filepath"
    "strings"

    "c20/internal/ast"
)

// Emit writes JS files and a small runtime shim to outDir.
func Emit(programs []ast.Program, outDir string) error {
    // 1) Ensure runtime shim exists in outDir.
    if err := os.WriteFile(filepath.Join(outDir, "cobol_compat.js"), []byte(runtimeShim), 0o644); err != nil {
        return err
    }

    // 2) Generate each program as <PROGRAM-ID>.js
    for _, p := range programs {
        name := sanitize(p.ID) + ".js"
        var b strings.Builder
        fmt.Fprintf(&b, "// Auto-generated by C_20 (MVP)\n")
        fmt.Fprintf(&b, "// Source: %s\n", p.Source)
        fmt.Fprintf(&b, "// Notes: This file mirrors a tiny subset of COBOL semantics.\n\n")
        fmt.Fprintf(&b, "\"use strict\";\n")
        fmt.Fprintf(&b, "const COBOL = require('./cobol_compat');\n\n")
        fmt.Fprintf(&b, "// Entry point equivalent to PROCEDURE DIVISION.\n")
        fmt.Fprintf(&b, "function main() {\n")
        if len(p.Stmts) == 0 {
            fmt.Fprintf(&b, "  // (no statements parsed)\n")
        }
        for _, s := range p.Stmts {
            switch v := s.(type) {
            case ast.DisplayLiteral:
                // DISPLAY "literal".
                fmt.Fprintf(&b, "  // COBOL: DISPLAY %q\n", v.Text)
                fmt.Fprintf(&b, "  COBOL.displayLiteral(%q);\n", v.Text)
            case ast.StopRun:
                fmt.Fprintf(&b, "  // COBOL: STOP RUN.\n")
                fmt.Fprintf(&b, "  return;\n")
            default:
                fmt.Fprintf(&b, "  // TODO: unsupported stmt in MVP\n")
            }
        }
        fmt.Fprintf(&b, "}\n\n")
        fmt.Fprintf(&b, "if (require.main === module) {\n  main();\n}\n")

        if err := os.WriteFile(filepath.Join(outDir, name), []byte(b.String()), 0o644); err != nil {
            return err
        }
    }

    return nil
}

func sanitize(s string) string {
    if s == "" { return "PROG" }
    var out []rune
    for _, r := range s {
        if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') {
            out = append(out, r)
        } else {
            out = append(out, '_')
        }
    }
    if len(out) == 0 { return "PROG" }
    if out[0] >= '0' && out[0] <= '9' {
        return "_" + string(out)
    }
    return string(out)
}

const runtimeShim = `
// Tiny COBOL runtime for Node.js (MVP).
// We keep it dependency-free to make the first run easy.
// Future: add decimal.js for exact decimal arithmetic, MOVE rules, file I/O, etc.

"use strict";

module.exports = {
  // DISPLAY of a string literal -> console.log
  displayLiteral: function (s) {
    // COBOL DISPLAY does not append quotes; most runtimes add a newline.
    // Using console.log is enough for MVP behavior.
    console.log(String(s));
  },

  // Placeholder for future features:
  // move, compute, sizeError handling, packed decimal, file I/O...
};
`
